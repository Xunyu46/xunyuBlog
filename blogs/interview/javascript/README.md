---
title: 面试万字总结（JS 篇）
date: 2023-10-24
sidebar: "auto"
categories:
  - 面试
tags:
  - JS
publish: true
---

# 面试万字总结（JS 篇）

# 一、JS 基础

## 1.1 Js 有哪些数据类型

::: tip
JavaScript 共有八种数据类型

基本数据类型： Undefined、Null、Boolean、Number、String、Symbol、BigInt。

引用数据类型：Object

其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：

- Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。
  :::

## 1.2 说说你对堆区和栈区的理解

::: tip
**在操作系统中，内存被分为栈区和堆区**

- 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
- 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。

**在数据结构中：**

- 在数据结构中，栈中数据的存取方式为先进后出。
- 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。

**数据的储存方式**

- 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
  :::

## 1.3 数据类型检测的方式有哪些

::: tip
然后判断数据类型的方法一般可以通过：**typeof**、**instanceof**、**constructor**、**toString**四种常用方法

| 不同类型的优缺点 | typeof                                                        | instanceof                          | constructor                                    | Object.prototype.toString.call        |
| ---------------- | ------------------------------------------------------------- | ----------------------------------- | ---------------------------------------------- | ------------------------------------- |
| 优点             | 使用简单                                                      | 能检测出`引用类型`                  | 基本能检测所有的类型（除了 null 和 undefined） | 检测出所有的类型                      |
| 缺点             | 只能检测出除 null 外的基本数据类型和引用数据类型中的 function | 不能检测出基本类型，且不能跨 iframe | constructor 易被修改，也不能跨 iframe          | IE6 下，undefined 和 null 均为 Object |

:::

## 1.4 判断数组的方式有哪些

::: tip

- 通过 Object.prototype.toString.call()做判断
- 通过原型链做判断
- 通过 ES6 的 Array.isArray()做判断
- 通过 instanceof 做判断
- 通过 Array.prototype.isPrototypeOf
  :::

## 1.5 null 和 undefined 区别

::: tip

- 首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。
- undefined 代表的含义是**未定义**，null 代表的含义是**空对象**。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。
- undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。
- 当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
  :::

## 1.6 typeof null 的结果是什么，为什么？

:::tip
typeof null 的结果是 Object。

在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 **类型标签(1-3 bits)** 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：

```php
000: object   - 当前存储的数据指向一个对象。
  1: int      - 当前存储的数据是一个 31 位的有符号整数。
010: double   - 当前存储的数据指向一个双精度的浮点数。
100: string   - 当前存储的数据指向一个字符串。
110: boolean  - 当前存储的数据是布尔值。

```

如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。

有两种特殊数据类型：

- undefined 的值是 (-2)30(一个超出整数范围的数字)；
- null 的值是机器码 NULL 指针(null 指针的值全是 0)

那也就是说 null 的类型标签也是 000，和 Object 的类型标签一样，所以会被判定为 Object。
:::

## 1.7 为什么 0.1+0.2 ! == 0.3，如何让其相等 (精度丢失)

::: tip
计算机是通过二进制的方式存储数据的，所以计算机计算 0.1+0.2 的时候，实际上是计算的两个数的二进制的和。

在 Js 中只有一种数字类型：Number，它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留 52 位，再加上前面的 1，其实就是保留 53 位有效数字，剩余的需要舍去，遵从“0 舍 1 入”的原则。

根据这个原则，0.1 和 0.2 的二进制数相加，再转化为十进制数就是：`0.30000000000000004`。所以不相等

解决方法就是设置一个误差范围，通常称为“机器精度”。对 JavaScript 来说，这个值通常为 2-52，在 ES6 中，提供了`Number.EPSILON`属性，而它的值就是 2-52，只要判断`0.1+0.2-0.3`是否小于`Number.EPSILON`，如果小于，就可以判断为 0.1+0.2 ===0.3

```javascript
function numberepsilon(arg1, arg2) {
  return Math.abs(arg1 - arg2) < Number.EPSILON;
}

console.log(numberepsilon(0.1 + 0.2, 0.3)); // true
```

:::

## 1.8 如何获取安全的 undefined 值？

::: tip
因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void \_\_\_ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。
:::

## 1.9 typeof NaN 的结果是什么？

::: tip
NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

```csharp
typeof NaN; // "number"

```

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反的值。所谓的非自反就是说，NaN 与谁都不相等，包括它本身，但在 NaN ！= NaN 下会返回 true
:::

## 1.10 isNaN 和 Number.isNaN 函数的区别？

::: tip

- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。
  :::

## 1.11 == 操作符的强制类型转换规则是什么？

::: tip
对于 `==` 来说，如果对比双方的类型**不一样**，就会进行**类型转换**。假如对比 `x` 和 `y` 是否相同，就会进行如下判断流程：

1. 首先会判断两者类型是否**相同，** 相同的话就比较两者的大小；
2. 类型不相同的话，就会进行类型转换；
3. 会先判断是否在对比 `null` 和 `undefined`，是的话就会返回 `true`
4. 判断两者类型是否为 `string` 和 `number`，是的话就会将字符串转换为 `number`

```ini
1 == '1'
      ↓
1 ==  1

```

1. 判断其中一方是否为 `boolean`，是的话就会把 `boolean` 转为 `number` 再进行判断

```ini
'1' == true
        ↓
'1' ==  1
        ↓
 1  ==  1

```

1. 判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原始类型再进行判断

```ini
'1' == { name: 'js' }        ↓'1' == '[object Object]'

```

其流程图如下：

![微信截图_20221004091412.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/446f656981cc4acb92f92ef6c57c3686~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)
:::

## 1.12 其他值类型转成字符串的转换规则？

::: tip

- Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"，
- Boolean 类型，true 转换为 "true"，false 转换为 "false"。
- Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。
- Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。
- 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。
  :::

## 1.13. 其他值类型转成数字的转换规则？

::: tip

- Undefined 类型的值转换为 NaN。
- Null 类型的值转换为 0。
- Boolean 类型的值，true 转换为 1，false 转换为 0。
- String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。
- Symbol 类型的值不能转换为数字，会报错。
- 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

为了将值转换为相应的基本类型值， 隐式转换会首先检查该值是否有 valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。

如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。
:::

## 1.14 其他值类型转成布尔类型的转换规则？

::: tip
以下这些是假值： undefined 、 null 、 false 、 +0、-0 和 NaN 、 ""

假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。
:::

## 1.15. || 和 && 操作符的返回值？

::: tip
|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。

- 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。
- && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果
:::

## 1.16. Object.is() 与比较操作符 “`===`”、“`==`” 的区别？

::: tip

- 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。
- 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。
- 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。
  :::

## 1.17. 什么是 JavaScript 中的包装类型？

::: tip
在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象。如：

```ini
const a = "abc";
a.length; // 3

```

在访问`'abc'.length`时，JavaScript 将`'abc'`在后台转换成`String('abc')`，然后再访问其`length`属性。
:::

## 1.18 Js 中隐式转换规则

::: tip
在 if 语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。

![微信截图_20221004091517.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8249e191d95c46a8b66effb504b3de93~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

坑: 判断时, 尽量不要用 `= =` , 要用 `= = =` ( 两个等号判断, 如果类型不同, 默认会进行隐式类型转换再比较)
:::

## 1.19 说说你对 this 的理解

::: tip
this`是一个在运行时才进行绑定的引用`，在不同的情况下它可能会被绑定不同的对象。
:::

## 1.20 如何判断 this 的指向

::: tip

- 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
- 第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
- 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
- 第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

#### **this 绑定的优先级**

new 绑定优先级 > 显示绑定优先级 > 隐式绑定优先级 > 默认绑定优先级
:::

## 1.21 Map 和 Object 的区别

::: tip
| | Map | Object |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 意外的键 | Map 默认情况不包含任何键，只包含显式插入的键。 | Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |
| 键的类型 | Map 的键可以是任意值，包括函数、对象或任意基本类型。 | Object 的键必须是 String 或是 Symbol。 |
| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 | Object 的键是无序的 |
| Size | Map 的键值对个数可以轻易地通过 size 属性获取 | Object 的键值对个数只能手动计算 |
| 迭代 | Map 是 iterable 的，所以可以直接被迭代。 | 迭代 Object 需要以某种方式获取它的键然后才能迭代。 |
| 性能 | 在频繁增删键值对的场景下表现更好。 | 在频繁添加和删除键值对的场景下未作出优化。 |
:::

## 1.22 说说你对 JSON 的理解

::: tip
JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。

在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。

因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。

在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，

- **JSON.stringify** 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。
- **JSON.parse()** 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。
  :::

## 1.221 String 和 JSON.stringify 的区别

::: tip

```javascript
console.log(String("abc")); // abc
console.log(JSON.stringify("abc")); // "abc"

console.log(String({ key: "value" })); // [object Object]
console.log(JSON.stringify({ key: "value" })); // {"key":"value"}

console.log(String([1, 2, 3])); // 1,2,3
console.log(JSON.stringify([1, 2, 3])); // [1,2,3]

const obj = {
  title: "devpoint",
  toString() {
    return "obj";
  },
};
console.log(String(obj)); // obj
console.log(JSON.stringify(obj)); // {"title":"devpoint"}
```

- 当需要将一个数组和一个普通对象转换为字符串时，经常使用`JSON.stringify`。
- 如果需要对象的`toString`方法被重写，则需要使用 String()。
- 在其他情况下，使用`String()`将变量转换为字符串。
  :::

## 1.23 什么是伪数组(类数组)

::: tip
一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。

常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。
:::

## 1.24 类数组转换成数组的方法有哪些

::: tip
常见的类数组转换为数组的方法有这样几种：

- 通过 call 调用数组的 slice 方法来实现转换

```javascript
Array.prototype.slice.call(arrayLike);
```

- 通过 call 调用数组的 splice 方法来实现转换

```javascript
Array.prototype.splice.call(arrayLike, 0);
```

- 通过 apply 调用数组的 concat 方法来实现转换

```ini
Array.prototype.concat.apply([], arrayLike);

```

- 通过 Array.from 方法来实现转换

```csharp
Array.from(arrayLike);

```

:::

## 1.25 **Unicode、UTF-8、UTF-16、UTF-32 的区别？**

::: tip

- `Unicode` 是编码字符集（字符集），而`UTF-8`、`UTF-16`、`UTF-32`是字符集编码（编码规则）；
- `UTF-16` 使用变长码元序列的编码方式，相较于定长码元序列的`UTF-32`算法更复杂，甚至比同样是变长码元序列的`UTF-8`也更为复杂，因为其引入了独特的**代理对**这样的代理机制；
- `UTF-8`需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而`UTF-16`不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；
- 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用`UTF-8`就比`UTF-16`节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么`UTF-16`就占优势了，可以节省很多空间；
  :::

## 1.26 常见的位运算符有哪些？其计算规则是什么？

::: tip
现代计算机中数据都是以二进制的形式存储的，即 0、1 两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。

常见的位运算有以下几种：

| 运算符 | 描述 | 运算规则                                                   |     |
| ------ | ---- | ---------------------------------------------------------- | --- |
| `&`    | 与   | 两个位都为 1 时，结果才为 1                                |     |
| `      | 或   | 两个位都为 0 时，结果才为 0                                |     |
| `^`    | 异或 | 两个位相同为 0，相异为 1                                   |     |
| `~`    | 取反 | 0 变 1，1 变 0                                             |     |
| `<<`   | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补 0               |     |
| `>>`   | 右移 | 各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃 |     |

:::

## 1.27 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?

::: tip
`arguments`是一个对象，它的属性是从 0 开始依次递增的数字，还有`callee`和`length`等属性，与数组相似；但是它却没有数组常见的方法属性，如`forEach`, `reduce`等，所以叫它们类数组。

要遍历类数组，有三个方法：

（1）将数组的方法应用到类数组上，这时候就可以使用`call`和`apply`方法，如：

```javascript
function foo() {
  Array.prototype.forEach.call(arguments, (a) => console.log(a));
}
```

（2）使用 Array.from 方法将类数组转化成数组：‌

```javascript
function foo() {
  const arrArgs = Array.from(arguments);
  arrArgs.forEach((a) => console.log(a));
}
```

（3）使用展开运算符将类数组转化成数组

```javascript
function foo() {
  const arrArgs = [...arguments];
  arrArgs.forEach((a) => console.log(a));
}
```

:::

## 1.28 escape、encodeURI、encodeURIComponent 的区别

::: tip

- encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。
- encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。
- escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。
  :::

## 1.29 什么是尾调用，使用尾调用有什么好处？

::: tip
尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。

**但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。**
:::

## 1.30 use strict 是什么? 它有什么用？

::: tip
use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：

- 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;
- 消除代码运行的不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的 Javascript 做好铺垫。

区别：

- 禁止使用 with 语句。
- 禁止 this 关键字指向全局对象。
- 对象不能有重名的属性。
  :::

## 1.31 如何判断一个对象是否属于某个类？

::: tip

- 第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
- 第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。
- 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。
  :::

## 1.32 强类型语言和弱类型语言的区别

::: tip

- **强类型语言**：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java 和 C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。
- **弱类型语言**：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript 语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如 JavaScript 是弱类型定义的，在 JavaScript 中就可以将字符串'12'和整数 3 进行连接得到字符串'123'，在相加的时候会进行强制类型转换。

两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。
:::

## 1.33 解释性语言和编译型语言的区别

::: tip
（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下

- 解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；
- 只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；
- JavaScript、Python 等属于解释型语言。

（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如 exe 格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行 exe 文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：

- 一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；
- 与特定平台相关，一般无法移植到其他平台；
- C、C++等属于编译型语言。

**两者主要区别在于：** 后者源程序编译后即可在该平台运行，前者是在运行期间才编译。所以后者运行速度快，前者跨平台性好。
:::

## 1.34 for...in 和 for...of 的区别

::: tip
for…of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口的数据结构（数组、对象等）并且返回各项的值，和 ES3 中的 for…in 的区别如下

- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；
- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；
- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；

**总结：** for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。
:::

## 1.35 ajax、axios、fetch 的区别

::: tip
**（1）AJAX** Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：

- 本身是针对 MVC 编程，不符合前端 MVVM 的浪潮
- 基于原生 XHR 开发，XHR 本身的架构不清晰
- 不符合关注分离（Separation of Concerns）的原则
- 配置和调用方式非常混乱，而且基于事件的异步模型不友好。

**（2）Fetch** fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了 ES6 中的 promise 对象。Fetch 是基于 promise 设计的。Fetch 的代码结构比起 ajax 简单多。**fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象**。

fetch 的优点：

- 语法简洁，更加语义化
- 基于标准 Promise 实现，支持 async/await
- 更加底层，提供的 API 丰富（request, response）
- 脱离了 XHR，是 ES 规范里新的实现方式

fetch 的缺点：

- fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
- fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: 'include'})
- fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
- fetch 没有办法原生监测请求的进度，而 XHR 可以

**（3）Axios** Axios 是一种基于 Promise 封装的 HTTP 客户端，其特点如下：

- 浏览器端发起 XMLHttpRequests 请求
- node 端发起 http 请求
- 支持 Promise API
- 监听请求和返回
- 对请求和返回进行转化
- 取消请求
- 自动转换 json 数据
- 客户端支持抵御 XSRF 攻击
  :::

## 1.36 数组的遍历方法有哪些

::: tip
| **方法** | **是否改变原数组** | **特点** |
| ------------------------- | ------------------ | ------------------------------------------------------------ |
| forEach() | 否 | 数组方法，不改变原数组的长度，没有返回值 |
| map() | 否 | 数组方法，不改变原数组的长度，有返回值，可链式调用 |
| filter() | 否 | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 |
| for...of | 否 | for...of 遍历具有 Iterator 迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的 obj 对象，将异步循环变成同步循环 |
| every() 和 some() | 否 | 数组方法，some()只要有一个是 true，便返回 true；而 every()只要有一个是 false，便返回 false. |
| find() 和 findIndex() | 否 | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |
| reduce() 和 reduceRight() | 否 | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 |
:::

## 1.37 forEach 和 map 方法有什么区别

::: tip
这方法都是用来遍历数组的，两者区别如下：

- forEach()方法会针对每一个元素执行提供的函数，如果遍历的元素是引用数据类型，则可以改变指针指向的堆内存里的值，该方法没有返回值；
- map()方法返回一个新数组，新数组中的值为原数组调用函数处理之后的值，如果遍历的元素是引用数据类型，则可以改变指针指向的堆内存里的值
  :::

## 1.38 说说你对浅拷贝和深拷贝的理解

::: tip
**浅拷贝**

- 浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝
- 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址
- 即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址

常见的浅拷贝：

- Object.assign
- Object.create
- slice
- concat()
- 展开运算符

**深拷贝**

深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

- \_.cloneDeep()
- jQuery.extend()
- JSON.stringify()
- 手写循环递归
  :::

## 1.39 JSON.stringify 深拷贝的缺点

::: tip

- 如果 obj 里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果，时间将只是字符串的形式，而不是对象的形式
- 如果 obj 里面有 RegExp，则打印出来是空对象
- 如果对象中有函数或者 undefined，则会直接被丢掉
- 如果 json 里有对象是由构造函数生成的，则会丢掉对象的 constructon
  :::

## 1.40 知道 lodash 吗？它有哪些常见的 API ？

::: tip
Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。

- \_.cloneDeep 深度拷贝
- \_.reject 根据条件去除某个元素。
- \_.drop(array, [n=1] ) 作用：将 `array` 中的前 `n` 个元素去掉，然后返回剩余的部分.
  :::

## 1.41 LHS 和 RHS 查询

::: tip
`LHS (Left-hand Side)` 和 `RHS (Right-hand Side)` ，是在代码执行阶段 JS 引擎操作变量的两种方式，二者区别就是对变量的查询目的是 **变量赋值** 还是 **查询** 。

**LHS** 可以理解为变量在赋值操作符`(=)`的左侧，例如 `a = 1`，当前引擎对变量 `a` 查找的目的是**变量赋值**。这种情况下，引擎不关心变量 `a` 原始值是什么，只管将值 `1` 赋给 `a` 变量。

**RHS** 可以理解为变量在赋值操作符`(=)`的右侧，例如：`console.log(a)`，其中引擎对变量`a`的查找目的就是 **查询**，它需要找到变量 `a` 对应的实际值是什么，然后才能将它打印出来。
:::

## 1.42 includes 比 indexOf 好在哪？

::: tip
includes 可以检测`NaN`，indexOf 不能检测`NaN`，includes 内部使用了`Number.isNaN`对`NaN`进行了匹配
:::

## 1.43 AMD 和 CMD 的区别？

::: tip
| 模块化 | 代表应用 | 特点 |
| ------ | ---------- | ------------------------------------------------------------ |
| AMD | require.js | 1、AMD 的 api 默认一个当多个用 2、依赖前置，异步执行 |
| CMD | sea.js | 1、CMD 的 api 严格区分，推崇职责单一 2、依赖就近，按需加载，同步执行 |
:::

## 1.44 (a == 1 && a == 2 && a == 3) 有可能是 true 吗？

::: tip
**方案一：重写 toString()或 valueOf()**

```js
let a = {
  i: 1,
  toString: function () {
    return a.i++;
  },
};
console.log(a == 1 && a == 2 && a == 3); // true
```

**方案二：数组**

数组的 toString 接口默认调用数组的 join 方法，重写 join 方法。定义 a 为数字，每次比较时就会调用 toString()方法，我们把数组的 shift 方法覆盖 toString 即可：

```js
let a = [1, 2, 3];
a.toString = a.shift;
console.log(a == 1 && a == 2 && a == 3); // true
```

当然把 toString 改为 valueOf 也是一样效果：

```js
let a = [1, 2, 3];
a.valueOf = a.shift;
console.log(a == 1 && a == 2 && a == 3); // true
```

**方案三：使用 Object.defineProperty()**

Object.defineProperty()用于定义对象中的属性，接收三个参数：object 对象、对象中的属性，属性描述符。属性描述符中 get:访问该属性时自动调用。

```javascript
var _a = 1;
Object.defineProperty(this, "a", {
  get: function () {
    return _a++;
  },
});
console.log(a === 1 && a === 2 && a === 3); //true
```

:::

## 1.45 JS 中的 MUL 函数

::: tip
MUL 表示数的简单乘法。在这种技术中，将一个值作为参数传递给一个函数，而该函数将返回另一个函数，将第二个值传递给该函数，然后重复继续。例如:x*y*z 可以表示为

```javascript
const mul = (x) => (y) => (z) => x * y * z;

console.log(mul(1)(2)(3)); // 6
```

:::

## 1.46 深度遍历广度遍历的区别？

::: tip
对于算法来说 无非就是时间换空间 空间换时间

- 1、深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大
- 2、深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点
- 3、深度优先采用的是**堆栈**的形式, 即先进后出
- 4、广度优先则采用的是**队列**的形式, 即先进先出
  :::

## 1.47 JS 中的设计模式有哪些？

::: tip

#### **单例模式**

保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

#### **策略模式**

定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。

#### **代理模式**

为一个对象提供一个代用品或占位符，以便控制对它的访问。

#### **中介者模式**

通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。

#### **装饰者模式**

在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。
:::

## 1.48 forEach 如何跳出循环？

::: tip
forEach 是不能通过`break`或者`return`来实现跳出循环的，为什么呢？实现过 forEach 的同学应该都知道，forEach 的的回调函数形成了一个作用域，在里面使用`return`并不会跳出，只会被当做`continue`

可以利用`try catch`

```javascript
function getItemById(arr, id) {
  var item = null;
  try {
    arr.forEach(function (curItem, i) {
      if (curItem.id == id) {
        item = curItem;
        throw Error();
      }
    });
  } catch (e) {}
  return item;
}
```

:::

## 1.49 JS 中如何将页面重定向到另一个页面？

::: tip
1、使用 location.href：window.location.href ="url"

2、使用 location.replace： window.location.replace("url");
:::

## 1.50 移动端如何实现上拉加载，下拉刷新？

::: tip
**上拉加载**

上拉加载的本质是页面触底，或者快要触底时的动作

判断页面触底我们需要先了解一下下面几个属性

- `scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是 0，它是一个变化的值
- `clientHeight`:它是一个定值，表示屏幕可视区域的高度；
- `scrollHeight`：页面不能滚动时也是存在的,此时 scrollHeight 等于 clientHeight。scrollHeight 表示`body`所有元素的总长度(包括 body 元素自身的 padding)

综上我们得出一个触底公式：

```js
scrollTop + clientHeight >= scrollHeight;
```

**下拉刷新**

下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作

关于下拉刷新的原生实现，主要分成三步：

- 监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；
- 监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助 CSS3 的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；
- 监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置
  :::

## 1.51 JS 中的数组和函数在内存中是如何存储的？

::: tip
JavaScript 中的数组存储大致需要分为两种情况：

- 同种类型数据的数组分配连续的内存空间
- 存在非同种类型数据的数组使用哈希映射分配内存空间

> 温馨提示：可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）。
> :::

# 二、闭包与作用域

## 2.1 什么是闭包？

::: tip

- ✅ 官方说法：闭包就是指有权访问另一个函数作用域中的变量的函数。
- ✅ MDN 说法：闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。

**深度回答**

浏览器在加载页面会把代码放在栈内存（ ECStack ）中执行，函数进栈执行会产生一个私有上下文（ EC ），此上下文能保护里面的使用变量（ AO ）不受外界干扰，并且如果当前执行上下文中的某些内容，被上下文以外的内容占用，当前上下文不会出栈释放，这样可以保存里面的变量和变量值，所以我认为闭包是一种保存和保护内部私有变量的机制。
:::

## 2.2 闭包的作用

::: tip
闭包有两个常用的用途；

- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来**创建私有变量**。
- 闭包的另一个用途是使已经运行结束的函数上下文中的**变量对象继续留在内存中**，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。
  :::

## 2.3 闭包在项目中的引用场景，以及带来的问题

::: tip
在实际的项目中，会基于闭包把自己编写的模块内容包裹起来，这样编写就可以保护自己的代码是私有的，防止和全局变量或者是其他的代码冲突，这一点是利用保护机制。

但是不建议过多的使用闭包，因为使用不被释放的上下文，是占用栈内存空间的，过多的使用会导致导致内存泄漏。

解决闭包带来的内存泄漏问题的方法是：使用完闭包函数后手动释放。
:::

## 2.4 闭包的使用场景

::: tip

1. `return` 回一个函数
2. 函数作为参数
3. IIFE（自执行函数）
4. 循环赋值
5. 使用回调函数就是在使用闭包
6. 节流防抖
7. 函数柯里化
   :::

## 2.5 闭包的执行过程

::: tip

1. 形成私有上下文

2. 进栈执行

3. 一系列操作

   (1). 初始化作用域链（两头<当前作用域，上级作用域>）

   (2). 初始化 this

   (3). 初始化 arguments

   (4). 赋值形参

   (5). 变量提升

   (6). 代码执行

   - 遇到变量就先看是否是自己私有的，不是自己私有的按照作用域链上查找，如果不是上级的就继续线上查找，，直到 EC(G)，变量的查找其实就是一个作用域链的拼接过程，拼接查询的链式就是作用域链。

4. 正常情况下，代码执行完成之后，私有上下文出栈被回收。但是遇到特殊情况，如果当前私有上下文执行完成之后中的某个东西被执行上下文以外的东西占用，则当前私有上下文就不会出栈释放，也就是形成了不被销毁的上下文，闭包。
   :::

## 2.6 执行上下文的类型

::: tip
**（1）全局执行上下文**

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的 window 对象，并且设置 this 的值等于这个全局对象，一个程序中只有一个全局执行上下文。

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

**（3）** `eval`**函数执行上下文**

执行在 eval 函数中的代码会有属于他自己的执行上下文，不过 eval 函数不常使用，不做介绍。
:::

## 2.7 执行上下文栈是什么

::: tip

- JavaScript 引擎使用执行上下文栈来管理执行上下文
- 当 JavaScript 执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。
  :::

## 2.8 执行上下文的三个阶段

::: tip
**创建阶段 → 执行阶段 → 回收阶段**

---

**创建阶段**

（1）this 绑定

- 在全局执行上下文中，this 指向全局对象（window 对象）
- 在函数执行上下文中，this 指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined

（2）创建词法环境组件

- 词法环境是一种有**标识符——变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。
- 词法环境的内部有两个组件：**加粗样式**：环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域

（3）创建变量环境组件

- 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。

**执行阶段**

在这阶段，执行变量赋值、代码执行

如果 `Javascript` 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 `undefined` 值

**回收阶段**

执行上下文出栈等待虚拟机回收执行上下文
:::

## 2.9 谈谈你对作用域的理解

::: tip

- 作用域可以视为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域根据标识符名称进行变量查找。
- 简单来说作用域就是变量的有效范围。在一定的空间里可以对变量数据进行读写操作，这个空间就是变量的作用域。

#### （1）全局作用域

- 直接写在 script 标签的 JS 代码，都在全局作用域。在全局作用域下声明的变量叫做全局变量（在块级外部定义的变量）。

- 全局变量在全局的任何位置下都可以使用；全局作用域中无法访问到局部作用域的中的变量。

- 全局作用域在页面打开的时候创建，在页面关闭时销毁。

- **所有 window 对象的属性拥有全局作用域**

  _var 和 function 命令声明的全局变量和函数是 window 对象的属性和方法_

  let 命令、const 命令、class 命令声明的全局变量，不属于 window 对象的属性

#### （2）函数作用域(局部作用域)

- 调用函数时会创建函数作用域，函数执行完毕以后，作用域销毁。每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的。
- 在函数作用域中可以访问全局变量，在函数的外面无法访问函数内的变量。
- 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一作用域中寻找，直到找到全局作用域，如果全局作用域中仍然没有找到，则会报错。

#### （3）块级作用域

- ES6 之前 JavaScript 采用的是函数作用域+词法作用域，ES6 引入了块级作用域。
- 任何一对花括号{}中的语句集都属于一个块,**在块中使用 let 和 const 声明的变量**，外部是访问不到的，这种作用域的规则就叫块级作用域。
- 通过 var 声明的变量或者非严格模式下创建的函数声明没有块级作用域。

#### （4）词法作用域

- 词法作用域是静态的作用域，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由**函数被声明时所处的位置**决定。
- 编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过中如何对它们进行查找。
- 换句话说，词法作用域就是你在写代码的时候就已经决定了变量的作用域。
  :::

## 2.10 什么是作用域链

::: tip
当在`js`中使用一个变量的时候，首先`js`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域，这样的变量作用域访问的链式结构, 被称之为作用域链

**深度回答**

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。
:::

## 2.11 作用域链的作用

::: tip
作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**
:::

## 2.12 作用域的常见应用场景

::: tip
作用域的一个常见运用场景之一，就是 **模块化**。

由于 javascript 并未原生支持模块化导致了很多令人口吐芬芳的问题，比如全局作用域污染和变量名冲突，代码结构臃肿且复用性不高。在正式的模块化方案出台之前，开发者为了解决这类问题，想到了使用函数作用域来创建模块的方案。
:::

## 2.13 说说 Js 中的预解析？

::: tip
JS 引擎在运行一份代码的时候，会按照下面的步骤进行工作：

1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值

2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用

3.先提升 function，在提升 var
:::

## 2.14 变量提升与函数提升的区别？

::: tip
**变量提升**

简单说就是在 JavaScript 代码执行前引擎会先进行预编译，预编译期间会将`变量声明与函数声明`提升至其`对应作用域的最顶端`，`函数内声明的变量`只会提升至`该函数作用域最顶层`，`当函数内部定义的一个变量与外部相同时`，那么`函数体内的这个变量就会被上升到最顶端`。

**函数提升**

函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升

函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上
:::

## 2.14 如何延长作用域链？

::: tip
作用域链是可以延长的。

延长作用域链： 执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。

具体来说就是执行这两个语句时，作用域链都会得到加强

1. try - catch 语句的 catch 块：会创建一个新的变量对象，包含的是被抛出的错误对 象的声明。
2. with 语句：with 语句会将指定的对象添加到作用域链中。
   :::

## 2.15 浏览器的垃圾回收机制

::: tip

#### （1）内存的生命周期

JS 环境中分配的内存, 一般有如下生命周期：

1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存

2. 内存使用：即读写内存，也就是使用变量、函数等

3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存

   全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉

#### （2）垃圾回收的概念

**垃圾回收**：JavaScript 代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

**回收机制**：

- Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
- JavaScript 中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
- 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

#### （3）垃圾回收的方式

**1.引用计数法**

- 这个用的相对较少，IE 采用的引用计数算法。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个引用次数变为 0 时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。
- 这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是 2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是 0，就会引起循环引用。

**2.标记清除法**

现代的浏览器已经不再使用引用计数算法了。

现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。

- 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
- 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

#### （4）如何减少垃圾回收

虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。

- **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为 0，以此来达到清空数组的目的。
- **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为 null，尽快被回收。
- **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。

#### （5）内存泄漏是什么

是指由于疏忽或错误造成程序未能释放已经不再使用的内存

#### （6）哪些情况会导致内存泄漏

以下四种情况会造成内存的泄漏：

- **意外的全局变量：** 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- **被遗忘的计时器或回调函数：** 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- **脱离 DOM 的引用：** 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。
- **闭包：** 不合理的使用闭包，从而导致某些变量一直被留在内存当中。
  :::

# 三、 函数与函数式编程

## 3.1 什么是函数式编程

::: tip
函数式编程是一种"编程范式"（programming paradigm），一种编写程序的方法论

主要的编程范式有三种：命令式编程，声明式编程和函数式编程

相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程
:::

## 3.2 函数式编程的优缺点

::: tip
**优点**

- 更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况
- 更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响
- 更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性
- 隐性好处。减少代码量，提高维护性

**缺点**

- 性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销
- 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式
- 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作
  :::

## 3.3 什么是纯函数，它有什么优点

::: tip
纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变

特性：

- 函数内部传入指定的值，就会返回确定唯一的值
- 不会造成超出作用域的变化，例如修改全局变量或引用传递的参数

优势：

- 使用纯函数，我们可以产生可测试的代码
- 不依赖外部环境计算，不会产生副作用，提高函数的复用性
- 可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读
- 可以组装成复杂任务的可能性。符合模块化概念及单一职责原则
  :::

## 3.4 什么是组合函数 (compose)

::: tip
在函数式编程中，有一个很重要的概念就是函数组合，实际上就是把处理的函数数据像管道一样连接起来，然后让数据穿过管道连接起来，得到最终的结果。

组合函数，其实大致思想就是将 多个函数组合成一个函数，c(b(a(a(1)))) 这种写法简写为 compose(c, b, a, a)(x) 。但是注意这里如果一个函数都没有传入，那就是传入的是什么就返回什么，并且函数的执行顺序是和传入的顺序相反的。

```js
var compose = (...funcs) => {
  // funcs(数组)：记录的是所有的函数
  // 这里其实也是利用了柯里化的思想，函数执行，生成一个闭包，预先把一些信息存储，供下级上下文使用
  return (x) => {
    var len = funcs.length;
    // 如果没有函数执行，直接返回结果
    if (len === 0) return x;
    if (len === 1) funcs[0](x);
    return funcs.reduceRight((res, func) => {
      return func(res);
    }, x);
  };
};
var resFn = compose(c, b, a, a);
resFn(1);
```

组合函数的思想，在很多框架中也被使用，例如：redux，实现效果来说是其实和上面的代码等价。
:::

## 3.5 什么是惰性函数

::: tip
惰性载入表示函数执行的分支只会在函数第一次掉用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了

**惰性函数相当于有记忆的功能一样，当它已经判断了一遍的话，第二遍就不会再判断了。**

比如现在要求写一个 test 函数，这个函数返回首次调用时的 new Date().getTime()，注意是首次，而且不允许有全局变量的污染

```javascript
//一般会这样实现
var test = (function () {
  var t = null;
  return function () {
    if (t) {
      return t;
    }
    t = new Date().getTime();
    return t;
  };
})();
// 用惰性函数实现
var test = function () {
  var t = new Date().getTime();
  test = function () {
    return t;
  };
  return test();
};
console.log(test());
console.log(test());
console.log(test());
```

:::

## 3.6 什么是高阶函数

::: tip
高阶函数是指使用其他函数作为参数、或者返回一个函数作为结果的函数。
:::

## 3.7 说说你对函数柯里化的理解

::: tip
柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。

函数柯里化的好处：

（1）参数复用：需要输入多个参数，最终只需输入一个，其余通过 arguments 来获取

（2）提前确认：避免重复去判断某一条件是否符合，不符合则 return 不再继续执行下面的操作

（3）延迟运行：避免重复的去执行程序，等真正需要结果的时候再执行
:::

## 3.8 什么是箭头函数，有什么特征

::: tip
使用 "箭头" ( => ) 来定义函数. 箭头函数相当于匿名函数, 并且简化了函数定义

**箭头函数的特征:**

- 箭头函数没有 this, this 指向定义箭头函数所处的外部环境
- 箭头函数的 this 永远不会变，call、apply、bind 也无法改变
- 箭头函数只能声明成**匿名函数**，但可以通过表达式的方式让箭头函数具名
- 箭头函数没有原型 prototype
- 箭头函数不能当做一个构造函数 因为 this 的指向问题
- 箭头函数没有 arguments 在箭头函数内部访问这个变量访问的是外部环境的 arguments, 可以使用 ...代替
  :::

## 3.9 说说你对递归函数的理解

::: tip
如果一个函数在内部调用自身本身，这个函数就是递归函数

其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解

一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回

**优点**：结构清晰、可读性强

**缺点**：效率低、调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。
:::

## 3.10 什么是尾递归

::: tip
尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。

在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出

这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误
:::

## 3.11 函数传参，传递复杂数据类型和简单数据类型有什么区别

::: tip
传递复杂数据类型传递的是引用的地址，修改会改变

简单数据类型传递的是具体的值，不会相互影响

```js
let a = 8;
function fn(a) {
  a = 9;
}
fn(a);
console.log(a); // 8 */

let a = { age: 8 };
function fn(a) {
  a.age = 9;
}
fn(a);
console.log(a.age); // 9
```

:::

## 3.12 函数声明与函数表达式的区别

::: tip
**函数声明：** funtion 开头，有函数提升

**函数表达式**: 不是 funtion 开头，没有函数提升
:::

## 3.13 什么是函数缓存，如何实现？

::: tip
**概念**

函数缓存，就是将函数运算过的结果进行缓存

本质上就是用空间（缓存存储）换时间（计算过程）

常用于缓存数据计算结果和缓存对象

**如何实现**

实现函数缓存主要依靠闭包、柯里化、高阶函数

**应用场景**

- 对于昂贵的函数调用，执行复杂计算的函数
- 对于具有有限且高度重复输入范围的函数
- 对于具有重复输入值的递归函数
- 对于纯函数，即每次使用特定输入调用时返回相同输出的函数
  :::

## 3.14 call、apply、bind 三者的异同

::: tip
**共同点** :

- 都可以改变 this 指向;
- 三者第一个参数都是`this`要指向的对象，如果如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`

**不同点**:

- call 和 apply 会调用函数, 并且改变函数内部 this 指向.
- call 和 apply 传递的参数不一样,call 传递参数使用逗号隔开,apply 使用数组传递，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入
- `bind`是返回绑定 this 之后的函数

**应用场景**

1. call 经常做继承.
2. apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值
3. bind 不调用函数,但是还想改变 this 指向. 比如改变定时器内部的 this 指向
   :::

# 四、原型与继承

## 4.1 说说面向对象的特性与特点

::: tip

- 封装性
- 继承性
- 多态性

面向对象编程具有灵活、代码可复用、容易维护和开发的有点、更适合多人合作的大型软件项目
:::

## 4.2 说说你对工厂模式的理解

::: tip
工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂

其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品
:::

## 4.3 创建对象有哪几种方式？

::: tip

1. 字面量的形式直接创建对象
2. 函数方法
   1. **工厂模式**，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。
   2. **构造函数模式**
   3. **原型模式**
   4. **构造函数模式+原型模式**，这是创建自定义类型的最常见方式。
   5. **动态原型模式**
   6. **寄生构造函数模式**
3. class 创建
   :::

## 4.4 JS 宿主对象和原生对象的区别

::: tip

```
原生对象
```

“`独立于宿主环境的 ECMAScript 实现提供的对象`”

包含：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError

```
内置对象
```

开发者不必明确实例化内置对象，它已被内部实例化了

同样是“独立于宿主环境”。而 ECMA-262 只定义了两个内置对象，即 Global 和 Math

```
宿主对象
```

BOM 和 DOM 都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript 官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过 ECMAScript 程序创建的对象
:::

## 4.5 JavaScript 内置的常用对象有哪些？并列举该对象常用的方法？

::: tip
**Number 数值对象，数值常用方法**

- Number.toFixed( ) 采用定点计数法格式化数字
- Number.toString( ) 将—个数字转换成字符串
- Number.valueOf( ) 返回原始数值

**String 字符串对象，字符串常用方法**

- Length 获取字符串的长度
- split()将一个字符串切割数组
- concat() 连接字符串
- indexOf()返回一个子字符串在原始字符串中的索引值。如果没有找到，则返回固定值 -1
- lastIndexOf() 从后向前检索一个字符串
- slice() 抽取一个子串

**Boolean 布尔对象，布尔常用方法**

- Boolean.toString() 将布尔值转换成字符串
- Boolean.valueOf() Boolean 对象的原始值的布尔值

**Array 数组对象，数组常用方法**

- join() 将一个数组转成字符串。返回一个字符串
- reverse() 将数组中各元素颠倒顺序
- delete 运算符只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)
- shift()删除数组中第一个元素，返回删除的那个值，并将长度减 1
- pop()删除数组中最后一个元素，返回删除的那个值，并将长度减 1
- unshift() 往数组前面添加一个或多个数组元素，长度会改变
- push() 往数组结尾添加一个或多个数组元素，长度会改变
- concat() 连接数组
- slice() 切割数组，返回数组的一部分
- splice()插入、删除或替换数组的元素
- toLocaleString() 把数组转换成局部字符串
- toString()将数组转换成一个字符串
- forEach()遍历所有元素
- every()判断所有元素是否都符合条件
- sort()对数组元素进行排序
- map()对元素重新组装，生成新数组
- filter()过滤符合条件的元素
- find() 查找 返回满足提供的测试函数的第一个元素的值。否则返回 undefined。
- some() 判断是否有一个满足条件 ，返回布尔值
- fill() 填充数组
- flat() 数组扁平化

**Function 函数对象，函数常用方法**

- Function.arguments 传递给函数的参数
- Function.apply() 将函数作为一个对象的方法调用
- Function.call() 将函数作为对象的方法调用
- Function.caller 调用当前函数的函数
- Function.length 已声明的参数的个数
- Function.prototype 对象类的原型
- Function.toString() 把函数转换成字符串

**Object 基础对象，对象常用方法**

- Object 含有所有 JavaScript 对象的特性的超类
- Object.constructor 对象的构造函数
- Object.hasOwnProperty( ) 检查属性是否被继承
- Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型
- Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性
- Object.toLocaleString( ) 返回对象的本地字符串表示
- Object.toString( ) 定义一个对象的字符串表示
- Object.valueOf( ) 指定对象的原始值

**Date 日期时间对象，日期常用方法**

- Date.getFullYear() 返回 Date 对象的年份字段
- Date.getMonth() 返回 Date 对象的月份字段
- Date.getDate() 返回一个月中的某一天
- Date.getDay() 返回一周中的某一天
- Date.getHours() 返回 Date 对象的小时字段
- Date.getMinutes() 返回 Date 对象的分钟字段
- Date.getSeconds() 返回 Date 对象的秒字段
- Date.getMilliseconds() 返回 Date 对象的毫秒字段
- Date.getTime() 返回 Date 对象的毫秒表示

**Math 数学对象，数学常用方法**

- Math 对象是一个`静态对象`
- Math.PI 圆周率
- Math.abs() 绝对值
- Math.ceil() 向上取整(整数加 1，小数去掉)
- Math.floor() 向下取整(直接去掉小数)
- Math.round() 四舍五入
- Math.pow(x，y) 求 x 的 y 次方
- Math.sqrt() 求平方根

**RegExp 正则表达式对象，正则常用方法**

- RegExp.exec() 检索字符串中指定的值。返回找到的值，并确定其位置。
- RegExp.test( ) 检索字符串中指定的值。返回 true 或 false。
- RegExp.toString( ) 把正则表达式转换成字符串
- RegExp.globa 判断是否设置了 "g" 修饰符
- RegExp.ignoreCase 判断是否设置了 "i" 修饰符
- RegExp.lastIndex 用于规定下次匹配的起始位置
- RegExp.source 返回正则表达式的匹配模式

**Error 异常对象**

- Error.message 设置或返回一个错误信息(字符串)
- Error.name 设置或返回一个错误名
- Error.toString( ) 把 Error 对象转换成字符串
  :::

## 4.6 说一下 hasOwnProperty、instanceof 方法

::: tip
**hasOwnProperty()** 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。

**instanceof** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。
:::

## 4.7 什么是原型对象，说说对它的理解

::: tip
**构造函数的内部的 prototype 属性指向的对象，就是构造函数的原型对象。**

原型对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个实例对象后，在这个对象的内部将包含一个指针(**\*\*proto\*\***)，这个指针指向构造函数的 原型对象，在 ES5 中这个指针被称为对象的原型。
:::

## 4.8 什么是原型链

::: tip
**原型链是一种查找规则**

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，这种链式查找过程称之为原型链
:::

## 4.9 原型链的终点是什么？

::: tip
原型链的尽头是 null。也就是**Object.prototype.\*\*proto\*\***
:::

## 4.10 Js 实现继承的方法

::: tip

### 1.原型链继承

**关键：子类构造函数的原型为父类构造函数的实例对象**

**缺点**：1、子类构造函数无法向父类构造函数传参。

2、所有的子类实例共享着一个原型对象，一旦原型对象的属性发生改变，所有子类的实例对象都会收影响

3、如果要给子类的原型上添加方法，必须放在 Son.prototype = new Father()语句后面

```javascript
function Father(name) {
  this.name = name;
}
Father.prototype.showName = function () {
  console.log(this.name);
};
function Son(age) {
  this.age = 20;
}
// 原型链继承,将子函数的原型绑定到父函数的实例上,子函数可以通过原型链查找到复函数的原型,实现继承
Son.prototype = new Father();
// 将Son原型的构造函数指回Son, 否则Son实例的constructor会指向Father
Son.prototype.constructor = Son;
Son.prototype.showAge = function () {
  console.log(this.age);
};
let son = new Son(20, "刘逍"); // 无法向父构造函数里传参
// 子类构造函数的实例继承了父类构造函数原型的属性,所以可以访问到父类构造函数原型里的showName方法
// 子类构造函数的实例继承了父类构造函数的属性,但是无法传参赋值,所以是this.name是undefined
son.showName(); // undefined
son.showAge(); // 20
```

### 2.借用构造函数继承

**关键：用 .call() 和 .apply()方法,在子类构造函数中,调用父类构造函数**

**缺点**：1、只继承了父类构造函数的属性，没有继承父类原型的属性。

2、无法实现函数复用，如果父类构造函数里面有一个方法，会导致每一个子类实例上面都有相同的方法。

```javascript
function Father(name) {
  this.name = name;
}
Father.prototype.showName = function () {
  console.log(this.name);
};
function Son(name, age) {
  Father.call(this, name); // 在Son中借用了Father函数,只继承了父类构造函数的属性，没有继承父类原型的属性。
  // 相当于 this.name = name
  this.age = age;
}
let s = new Son("刘逍", 20); // 可以给父构造函数传参
console.log(s.name); // '刘逍'
console.log(s.showName); // undefined
```

### 3.组合继承

**关键：原型链继承+借用构造函数继承**

**缺点**：1、使用组合继承时，父类构造函数会被调用两次，子类实例对象与子类的原型上会有相同的方法与属性，浪费内存。

```javascript
function Father(name) {
  this.name = name;
  this.say = function () {
    console.log("hello,world");
  };
}
Father.prototype.showName = function () {
  console.log(this.name);
};
function Son(name, age) {
  Father.call(this, name); //借用构造函数继承
  this.age = age;
}
// 原型链继承
Son.prototype = new Father(); // Son实例的原型上,会有同样的属性,父类构造函数相当于调用了两次
// 将Son原型的构造函数指回Son, 否则Son实例的constructor会指向Father
Son.prototype.constructor = Son;
Son.prototype.showAge = function () {
  console.log(this.age);
};
let p = new Son("刘逍", 20); // 可以向父构造函数里传参
// 也继承了父函数原型上的方法
console.log(p);
p.showName(); // '刘逍'
p.showAge(); // 20
```

### 4.原型式继承

**关键：创建一个函数，将要继承的对象通过参数传递给这个函数，最终返回一个对象，它的隐式原型指向传入的对象。** (**_Object.create()方法的底层就是原型式继承_**)

**缺点**：只能继承父类函数原型对象上的属性和方法，无法给父类构造函数传参

```javascript
function createObj(obj) {
  function F() {} // 声明一个构造函数
  F.prototype = obj; //将这个构造函数的原型指向传入的对象
  F.prototype.construct = F; // construct属性指回子类构造函数
  return new F(); // 返回子类构造函数的实例
}
function Father() {
  this.name = "刘逍";
}
Father.prototype.showName = function () {
  console.log(this.name);
};
const son = createObj(Father.prototype);
son.showName(); // undefined  继承了原型上的方法,但是没有继承构造函数里的name属性
```

### 5.寄生式继承

**关键：在原型式继承的函数里，给继承的对象上添加属性和方法，增强这个对象**

**缺点**：只能继承父类函数原型对象上的属性和方法，无法给父类构造函数传参

```javascript
function createObj(obj) {
  function F() {}
  F.prototype = obj;
  F.prototype.construct = F;
  F.prototype.age = 20; // 给F函数的原型添加属性和方法,增强对象
  F.prototype.showAge = function () {
    console.log(this.age);
  };
  return new F();
}
function Father() {
  this.name = "刘逍";
}
Father.prototype.showName = function () {
  console.log(this.name);
};
const son = createObj(Father.prototype);
son.showName(); // undefined
son.showAge(); // 20
```

### 6.寄生组合继承

**关键：原型式继承 + 构造函数继承**

**Js 最佳的继承方式，只调用了一次父类构造函数**

```javascript
function Father(name) {
  this.name = name;
  this.say = function () {
    console.log("hello,world");
  };
}
Father.prototype.showName = function () {
  console.log(this.name);
};
function Son(name, age) {
  Father.call(this, name);
  this.age = age;
}
Son.prototype = Object.create(Father.prototype); // Object.create方法返回一个对象，它的隐式原型指向传入的对象。
Son.prototype.constructor = Son;
const son = new Son("刘逍", 20);
console.log(son.prototype.name); // 原型上已经没有name属性了,所以这里会报错
```

### 7.混入继承

**关键：利用 Object.assign 的方法多个父类函数的原型拷贝给子类原型**

```javascript
function Father(name) {
  this.name = name;
}
Father.prototype.showName = function () {
  console.log(this.name);
};

function Mather(color) {
  this.color = color;
}
Mather.prototype.showColor = function () {
  console.log(this.color);
};

function Son(name, color, age) {
  // 调用两个父类函数
  Father.call(this, name);
  Mather.call(this, color);
  this.age = age;
}
Son.prototype = Object.create(Father.prototype);
Object.assign(Son.prototype, Mather.prototype); // 将Mather父类函数的原型拷贝给子类函数
const son = new Son("刘逍", "red", 20);
son.showColor(); // red
```

### 8. class 继承

**关键：class 里的 extends 和 super 关键字，继承效果与寄生组合继承一样**

```javascript
class Father {
  constructor(name) {
    this.name = name;
  }
  showName() {
    console.log(this.name);
  }
}
class Son extends Father {
  // 子类通过extends继承父类
  constructor(name, age) {
    super(name); // 调用父类里的constructor函数,等同于Father.call(this,name)
    this.age = age;
  }
  showAge() {
    console.log(this.age);
  }
}
const son = new Son("刘逍", 20);
son.showName(); // '刘逍'
son.showAge(); // 20
```

:::

# 五、异步与事件循环

## 5.1. 异步编程的实现方式?

::: tip
JavaScript 中的异步机制可以分为以下几种：

- **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。
- **Promise** 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。
- **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。
- **async 函数** 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。
  :::

## 5.2 并发与并行的区别？

::: tip

- 并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。
- 并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。
  :::

## 5.3 setTimeout、setInterval、requestAnimationFrame 的区别

::: tip

- **setTimeout**

执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责。但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间。

返回值`timeoutID`是一个正整数，表示定时器的编号。这个值可以传递给[`clearTimeout()`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FclearTimeout)来取消该定时器。

- **setInterval**

重复调用一个函数或执行一个代码片段，每次都精确的隔一段时间推入一个事件（但是，事件的执行时间不一定就不准确，还有可能是这个事件还没执行完毕，下一个事件就来了）。它返回一个 `interval ID`，该 ID 唯一地标识时间间隔，因此你可以稍后通过调用 [`clearInterval()`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FclearInterval) 来移除定时器。

**技术上，`clearTimeout()` 和 `clearInterval()`可以互换。但是，为了避免混淆，不要混用取消定时函数。**

- **requestAnimationFrame**

是 JS 实现动画的一种方式，它告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行
:::

## 5.4. 什么是回调地狱？回调地狱会带来什么问题？

::: tip
回调函数的层层嵌套，就叫做回调地狱。回调地狱会造成代码可复用性不强，可阅读性差，可维护性(迭代性差)，扩展性差等等问题。
:::

## Promise 语法

## 5.5. Promise 是什么

::: tip
Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。

**promise 本身只是一个容器,真正异步的是它的两个回调 resolve()和 reject()**

**promise 本质 不是控制 异步代码的执行顺序（无法控制） ， 而是控制异步代码结果处理的顺序**
:::

## 5.6 promise 实例有哪些状态，怎么改变状态

::: tip
（1）Promise 的实例有**三个状态**:

- Pending（进行中）
- Resolved（已完成）
- Rejected（已拒绝）

当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了状态就变成了 Resolved、没有完成失败了就变成了 Rejected。

**如何改变 promise 的状态**

- resolve(value): 如果当前是 pending 就会变为 resolved
- reject(error): 如果当前是 pending 就会变为 rejected
- 抛出异常: 如果当前是 pending 就会变为 rejected

注意：一旦从进行状态变成为其他状态就永远不能更改状态了。
:::

## 5.7 创建 Promise 实例有哪些方法

::: tip

- **new Promise((resolve,reject)=>{** ... **})**

**一般情况下都会使用**`new Promise()`**来创建 promise 对象，但是也可以使用**`promise.resolve`**和**`promise.reject`**这两个方法：**

- **Promise.resolve**

`Promise.resolve(value)`的返回值也是一个 promise 对象，可以对返回值进行.then 调用，代码如下：

```javascript
Promise.resolve(11).then(function (value) {
  console.log(value); // 打印出11
});
```

- **Promise.reject**

`Promise.reject` 也是`new Promise`的快捷形式，也创建一个 promise 对象。代码如下：

```javascript
Promise.reject(new Error(“出错了！！”));
```

:::

## 5.8 Promise 有哪些实例方法

::: tip
**then**

`then`方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为`resolved`时调用，第二个回调函数是 Promise 对象的状态变为`rejected`时调用。其中第二个参数可以省略。 `then`方法返回的是一个新的 Promise 实例（不是原来那个 Promise 实例）。因此可以采用链式写法，即`then`方法后面再调用另一个 then 方法。

**catch**

该方法相当于`then`方法的第二个参数，指向`reject`的回调函数。不过`catch`方法还有一个作用，就是在执行`resolve`回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入`catch`方法中。

**finally**

`finally`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。

下面是一个例子，服务器使用 Promise 处理请求，然后使用`finally`方法关掉服务器。

```scss
server.listen(port)
  .then(function () {
    // ...
  })
  .finally(server.stop);
```

`finally`方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是`fulfilled`还是`rejected`。这表明，`finally`方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。
:::

## 5.9 Promise 有哪些静态方法

::: tip
**all**

`all`方法可以完成并发任务， 它接收一个数组，数组的每一项都是一个`promise`对象，返回一个[`Promise`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise)实例。当数组中所有的`promise`的状态都达到`resolved`的时候，`all`方法的状态就会变成`resolved`，如果有一个状态变成了`rejected`，那么`all`方法的状态就会变成`rejected`。

**race**

`race`方法和`all`一样，接受的参数是一个每项都是`promise`的数组，但是与`all`不同的是，当最先执行完的事件执行完之后，就直接返回该`promise`对象的值。如果第一个`promise`对象状态变成`resolved`，那自身的状态变成了`resolved`；反之第一个`promise`变成`rejected`，那自身状态就会变成`rejected`。

**any**

它接收一个数组，数组的每一项都是一个`promise`对象，该方法会返回一个新的 `promise`，数组内的任意一个 `promise` 变成了`resolved`状态，那么由该方法所返回的 `promise` 就会变成`resolved`状态。如果数组内的 `promise` 状态都是`rejected`，那么该方法所返回的 `promise` 就会变成`rejected`状态，

**resolve、reject**

用来生成对应状态的 Promise 实例
:::

## 5.10 Promise.all、Promise.race、Promise.any 的区别

::: tip
**all：** 成功的时候返回的是**一个结果数组**，而失败的时候则返回**最先被 reject 失败状态的值**。

**race：** 哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。

**any：** 返回最快的成功结果，如果全部失败就返回失败结果。
:::

## 5.11 一个 promise 指定多个回调函数, 都会调用吗?

::: tip
都会调用，成功状态放在 then 的第一个参数里调用

```javascript
let p2 = new Promise((resolve, reject) => {
  resolve(1);
});
p2.then((value) => {
  console.log("第一个", value);
});
p2.then((value) => {
  console.log("第二个", value);
});
```

失败状态放在 then 的第二个参数里调用

```javascript
let p3 = new Promise((resolve, reject) => {
  reject(2);
});
p3.then(
  () => {},
  (value) => {
    console.log("第一个", value);
  }
);
p3.then(
  () => {},
  (value) => {
    console.log("第二个", value);
  }
);
```

:::

## 5.12 改变 promise 状态和指定回调函数谁先谁后?

::: tip

1. 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调
2. 如何先改状态再指定回调?
   - 在执行器中直接调用 resolve()/reject()
   - 延迟更长时间才调用 then()
3. 什么时候才能得到数据?
   - 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据
   - 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据
     :::

## 5.13 promise.then()返回的新 promise 的结果状态由什么决定?

::: tip

1. 简单表达: 由 then()指定的回调函数执行的结果决定
2. 详细表达:
   - 如果抛出异常, 新 promise 变为 rejected, 参数为抛出的异常
   - 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值
   - 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果
     :::

## 5.14 promise 如何串连多个操作任务?

::: tip

- promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用
- 通过 then 的链式调用串连多个同步/异步任务
  :::

## 5.15 promise 异常传透是什么?

::: tip
Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。

- 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,
- 前面任何操作出了异常, 都会传到最后失败的回调中处理
  :::

## 5.16 如何中断 promise 链?

::: tip

- 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数。 在回调函数中返回一个 pendding 状态的 promise 对象
  :::

## 5.17 promise 有什么缺点

::: tip
**代码层面**

- 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。
- 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
- 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

**语法层面**

- Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担
- Promise 传递中间值⾮常麻烦
- Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。
  :::

## async/await 语法

## 5.18 async 函数是什么

::: tip

- 一句话概括： 它就是 Generator 函数的语法糖，也就是处理异步操作的另一种`高级写法`
  :::

## 5.19 async 函数的实现原理

::: tip
async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。

```javascript
async function fn(args) {
  // ...
}

// 等同于

function fn(args) {
  return spawn(function* () {
    // spawn函数就是自动执行器
    // ...
  });
}
```

:::

## 5.20 async 函数的返回值

::: tip
`async`函数返回一个 Promise 对象。

`async`函数内部`return`语句返回的值，会成为`then`方法回调函数的参数。

`async`函数内部抛出错误，会导致返回的 Promise 对象变为`reject`状态。抛出的错误对象会被`catch`方法回调函数接收到。
:::

## 5.21 await 到底在等待什么?

::: tip
await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。

await 表达式的运算结果取决于它等的是什么。

- 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。
- 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
  :::

## 5.22 什么是顶层 await？

::: tip
从 ES2022 开始，允许在模块的顶层独立使用`await`命令，使得上面那行代码不会报错了。它的主要目的是使用`await`**解决模块异步加载的问题。**

```javascript
import { AsyncFun } from "module";
await AsyncFun();
console.log(123);
```

:::

## 5.23 如何用 await 让程序停顿指定的时间(休眠效果)

::: tip
JavaScript 一直没有休眠的语法，但是借助`await`命令就可以让程序停顿指定的时间

```javascript
function sleep(interval) {
  return new Promise((resolve) => {
    setTimeout(resolve, interval);
  });
}

// 用法
async function one2FiveInAsync() {
  for (let i = 1; i <= 5; i++) {
    console.log(i);
    await sleep(1000);
  }
}

one2FiveInAsync();
```

:::

## 5.24 await 的使用注意点

::: tip

1. `await`命令后面的`Promise`对象，运行结果可能是`rejected`，所以最好把`await`命令放在`try...catch`代码块中。
2. 多个`await`命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。
3. `await`命令只能用在`async`函数之中，如果用在普通函数，就会报错。
4. async 函数可以保留运行堆栈。
   :::

## 5.25 async 语法怎么捕获异常

::: tip
`async`函数内部的异常可以通过 `.catch()`或者 `try`/`catch`来捕获,区别是

- try/catch 能捕获所有异常,try 语句抛出错误后会执行 catch 语句，try 语句内后面的内容不会执行
- catch（）只能捕获异步方法中 reject 错误，并且 catch 语句之后的语句会继续执行

```javascript
async函数错误捕获，以登录功能为例
      async function getCatch () {
        await new Promise(function (resolve, reject) {
          reject(new Error('登录失败'))
        }).catch(error => {
          console.log(error)  // .catch（）能捕获到错误信息
        })
        console.log('登录成功') //  但是成功信息也会执行
      }

     async function getCatch () {
        try {
          await new Promise(function (resolve, reject) {
            reject(new Error('登录失败'))
          })
          console.log('登录成功')  // try抛出错误之后，就不会执行这条语句
        } catch (error) {
          console.log(error)  //  catch语句能捕获到错误信息
        }
      }
```

:::

## 5.26 async/await 对比 Promise 的优势

::: tip

- 代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担
- Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅
- 错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余
- 调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。
  :::

## 事件循环 Event Loop

## 5.27 JS 的执行机制(同步任务、异步任务)

::: tip
JS 是一门单线程语言，单线程就意味着，所有的任务需要排队，前一个任务结束，才会执行下一个任务。这样所导致的问题是：如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的觉。为了解决这个问题，JS 中出现了同步和异步。

**同步任务**：即主线程上的任务，按照顺序由上⾄下依次执⾏，当前⼀个任务执⾏完毕后，才能执⾏下⼀个任务。

**异步任务**：不进⼊主线程，⽽是进⼊任务队列的任务，执行完毕之后会产生一个回调函数,并且通知主线程。当主线程上的任务执行完后，就会调取最早通知自己的回调函数，使其进入主线程中执行。
:::

## 5.28 什么是 Event Loop

::: tip

- 事件循环 Event Loop 又叫事件队列，两者是一个概念

事件循环指的是 js 代码所在运行环境（浏览器、nodejs）编译器的一种解析执行规则。事件循环不属于 js 代码本身的范畴，而是属于 js 编译器的范畴，在 js 中讨论事件循环是没有意义的。换句话说，js 代码可以理解为是一个人在公司中具体做的事情， 而 事件循环 相当于是公司的一种规章制度。 两者不是一个层面的概念。
:::

## 5.29 宏任务与微任务的概念与区别

::: tip
为了协调任务有条不紊地在主线程上执行，页面进程引入了 **消息队列** 和 **事件循环机制**，渲染进程内部也会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 `for` 循环，不断地从这些任务队列中取出任务并执行任务。这些消息队列中的任务就称为 **宏任务**。

**微任务**是一个需要异步执行的回调函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。当 JS 执行一段脚本（一个宏任务）的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个 **微任务队列**。也就是说 **每个宏任务都关联了一个微任务队列**。
:::

## 5.30 常见的宏任务与微任务分别有哪些

::: tip
| 任务（代码） | 宏/微 任务 | 环境 |
| ---------------------- | ---------- | ----------- |
| | 宏任务 | 浏览器 |
| 事件 | 宏任务 | 浏览器 |
| 网络请求（Ajax） | 宏任务 | 浏览器 |
| setTimeout() 定时器 | 宏任务 | 浏览器/Node |
| fs.readFile() 读取文件 | 宏任务 | Node |
| Promise.then() | 微任务 | 浏览器/Node |
| async/await | 微任务 | 浏览器/Node |
:::

## 5.31 事件循环 Event Loop 执行机制

::: tip 1.进入到 script 标签,就进入到了第一次事件循环.

2.遇到同步代码，立即执行

3.遇到宏任务,放入到宏任务队列里.

4.遇到微任务,放入到微任务队列里.

5.执行完所有同步代码

6.执行微任务代码

7.微任务代码执行完毕，本次队列清空

8.寻找下一个宏任务，重复步骤 1
:::

## 5.32 为什么 Js 是单线程？

::: tip
Js 是单线程，但是浏览器是多线程。单线程是为了避免 UI 操作混乱，所有和 UI 操作相关的开发语言都应该是单线程。
:::

## 5.33 代码题易考点

::: tip

1. promise 本身是一个同步的代码，只有它后面调用的 then()方法里面的回调才是微任务
2. then 方法需要 Promise 里的 resolve 传值才会执行
3. await 右边的表达式还是会立即执行,表达式之后的代码才是微任务, await 微任务可以转换成等价的 promise 微任务分析
4. script 标签本身是一个`宏任务`， 当页面出现多个 script 标签的时候，浏览器会把 script 标签作为宏任务来解析
   :::

# 六、 ES6-ES2022 新语法

## 6.1 ES6(ES2015)

### 1. 说说 let 和 const

::: tip
**let:**

- 声明变量
- 没有变量提升
- 不可重复声明
- 具有块级作用域
- 声明变量后可以在使用时赋值

**const:**

- 只读常量
- 没有变量提升
- 不可重复声明
- 具有块级作用域
- 声明变量后必须立马赋值
  :::

### 2. let、const、var 的区别

::: tip
**（1）块级作用域：** 块作用域由 `{ }`包括，let 和 const 具有块级作用域，var 不存在块级作用域。块级作用域解决了 ES5 中的两个问题：

- 内层变量可能覆盖外层变量
- 用来计数的循环变量泄露为全局变量

**（2）变量提升：** var 存在变量提升，let 和 const 不存在变量提升，即在变量只能在声明之后使用，否在会报错。

**（3）给全局添加属性：** 浏览器的全局对象是 window，Node 的全局对象是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。

**（4）重复声明：** var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const 和 let 不允许重复声明变量。

**（5）暂时性死区：** 在使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**。使用 var 声明的变量不存在暂时性死区。

**（6）初始值设置：** 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。

**（7）指针指向：** let 和 const 都是 ES6 新增的用于创建变量的语法。 let 创建的变量是可以更改指针指向（可以重新赋值）。但 const 声明的变量是不允许改变指针的指向。

| **区别**           | **var** | **let** | **const** |
| ------------------ | ------- | ------- | --------- |
| 是否有块级作用域   | ×       | ✔️      | ✔️        |
| 是否存在变量提升   | ✔️      | ×       | ×         |
| 是否添加全局属性   | ✔️      | ×       | ×         |
| 能否重复声明变量   | ✔️      | ×       | ×         |
| 是否存在暂时性死区 | ×       | ✔️      | ✔️        |
| 是否必须设置初始值 | ×       | ×       | ✔️        |
| 能否改变指针指向   | ✔️      | ✔️      | ×         |

:::

### 3. 解构赋值

::: tip
**对象解构**

- 形式：`const { x, y } = { x: 1, y: 2 }`
- 默认：`const { x, y = 2 } = { x: 1 }`
- 改名：`const { x, y: z } = { x: 1, y: 2 }`

**数组解构**

- 规则：数据结构具有`Iterator接口`可采用数组形式的解构赋值
- 形式：`const [x, y] = [1, 2]`
- 默认：`const [x, y = 2] = [1]`

**函数参数解构**

- 数组解构：`function Func([x = 0, y = 1]) {}`
- 对象解构：`function Func({ x = 0, y = 1 } = {}) {}`

**应用场景:**

- 交换变量值：`[x, y] = [y, x]`
- 返回函数多个值：`const [x, y, z] = Func()`
- 定义函数参数：`Func([1, 2])`
- 提取 JSON 数据：`const { name, version } = packageJson`
- 定义函数参数默认值：`function Func({ x = 1, y = 2 } = {}) {}`
- 遍历 Map 结构：`for (let [k, v] of Map) {}`
- 输入模块指定属性和方法：`const { readFile, writeFile } = require("fs")`

**注意点**

- 匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值
- 解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象
- 解构默认值生效条件：属性值严格等于`undefined`
- 解构遵循匹配模式
- 解构不成功时变量的值等于`undefined`
- `undefined`和`null`无法转为对象，因此无法进行解构
  :::

### 4. 字符串的新增方法

::: tip
**includes**

返回布尔值，表示是否找到了参数字符串。

**startsWith**

返回布尔值，表示参数字符串是否在原字符串的头部。

**endsWith**

返回布尔值，表示参数字符串是否在原字符串的尾部。

**repeat**

`repeat`方法返回一个新字符串，表示将原字符串重复`n`次
:::

### 5. 展开运算符

::: tip
**（2）数组扩展运算符**

数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

```javascript
const arr = [1, 2, 3, 4, 5, 6];
const newArr = [...arr]; // 复制数组
const arr1 = ["two", "three"];
const arr2 = ["one", ...arr1]; // 合并数组
console.log(Math.max.call(null, ...arr)); // 将数组中的每一项作为参数使用
```

** (3) rest(剩余)参数**

扩展运算符被用在函数形参上时，**它还可以把一个分离的参数序列整合成一个数组**：

```javascript
function mutiple(...args) {
  let result = 1;
  for (var val of args) {
    result *= val;
  }
  return result;
}
mutiple(1, 2, 3, 4); // 24
```

:::

### 6. 数组新增的方法

::: tip
**Array.from()**

将类数组或者可迭代对象创建为一个新的数组，不改变原数组并返回这个新数组

**Array.of()**

**创建一个具有可变数量参数的新数组实例**，示例代码如下：

```javascript
Array.of(1); // [1]
Array.of(true, 1, "刘逍"); // [true, 1, '刘逍']
```

**findIndex**

根据给定的回调函数，找到匹配的第一个元素的索引，找不到返回-1

**find**

根据给定的回调函数，找到匹配的第一个元素，找不到返回 undefined

**fill**

将给定值填充数组，示例代码如下：

```js
const arr = [1, 2, 3, 4];
// 将给定值填充索引1-3
arr.fill("逍", 1, 3); // [ 1, '逍', '逍', 4 ]
```

**keys**

返回一个可迭代的对象，其内容为数组的 key，示例代码如下：

```js
const arr = [1, true, "逍"];
const keys = arr.keys();
for (const i of keys) {
  console.log(i); // 遍历结果 0 1 2
}
```

**values**

返回一个可迭代的对象，其内容为数组的 valu\*，示例代码如下：

```js
const arr = [1, true, "逍"];
const values = arr.values();
for (const i of values) {
  console.log(i); // 遍历结果 1 true 逍
}
```

**entries**

返回一个可迭代的对象，其内容是一个数组，索引 0 为原数组的元素，1 为原数组该位置的值，示例代码如下：

```js
const arr = [1, true, "逍"];

const iterator = arr.entries();
console.log(Array.from(iterator)); // [ [ 0, 1 ], [ 1, true ], [ 2, '逍' ] ]
```

:::

### 7. 对象新增方法

::: tip
**Object.is() (用于解决 NaN ≠= NaN，+0 === -0 的问题)**

用于比较两个值是否相等，用于解决 NaN ≠= NaN，+0 === -0 的问题，示例代码如下：

```javascript
console.log(NaN === NaN); // false
console.log(+0 === -0); // true

console.log(Object.is(NaN, NaN)); // true
console.log(Object.is(+0, -0)); // false
```

**Object.assign()**

将**所有可枚举属性的值从一个或多个源对象复制到目标对象，并返回目标对象**，示例代码如下：

```js
const person = Object.assign({}, { name: "刘逍" }, { age: 18 });
console.log(person); // { name: '刘逍', age: 18 }
```

**Object.getPrototypeOf()**

获取原型对象；

**Object.setPrototypeOf()**

设置原型对象。
:::

### 8.class 类

::: tip
JS 里的类就是构造函数的语法糖

**基本用法**

1. 类里面有个 constructor 函数,可以接收传递过来的参数,同时返回实例对象
2. constructor 函数只要 new 生成实例时,就会自动调用这个函数,如果我们不写这个函数,类也会自动生成这个函数
3. 公共属性放在 constructor 中，公共方法直接在类里面写函数声明,会自动添加至原型对象中
4. class 类没有变量提升,所以必须先定义类,才能通过类实例化对象
5. super()调用父类里的 constructor 方法,可以向里面传参,就等于 Father.call(this,x,y)，super 必须在子类的 this 前面调用
6. class 里面的方法的 this 指向的是调用者,如果调用者不是类的实例,就需要改变 this 的指向

```javascript
class Person {
  constructor(age) {
    // 属性
    this.myName = "刘逍";
    this.age = age;
  }
  // 静态方法
  static print() {
    console.log();
  }
  // 访问器
  get myName() {
    console.log("getter");
    return this.myName;
  }
  set myName(v) {
    console.log("setter" + v);
  }
  setName(v) {
    this.myName = v;
  }
}
```

**关键词**

**constructor**

`constructor()`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor()`方法，如果没有显式定义，一个空的`constructor()`方法会被默认添加。

**super**

`super`这个关键字，既可以当作函数使用，也可以当作对象使用。

`super`作为函数调用时，代表父类的构造函数。子类的构造函数必须执行一次`super`函数。`super`虽然代表了父类`A`的构造函数，**但是返回的是子类`B`的实例**

`super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

**getter、setter**

在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

**static**

如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。

**# 私有属性**

`ES2022`正式为`class`添加了私有属性，方法是在属性名之前使用`#`表示。私有属性只能在类的内部使用（`this.#count`）。如果在类的外部使用，就会报错。
:::

### 9. 模块化

::: tip
ES6**中允许我们使用 export 导出模块，使用 import 引入模块**
:::

### 10. Symbol

::: tip
ES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一

Symbol 值通过`Symbol()`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。
:::

### 11. Iterator

::: tip
Iterator 即迭代器，它是一种接口，为各种不同的数据结构提供了统一的访问机制，换句话说，只要有任何数据结构部署了迭代接口，就可以使用统一的方式的来遍历它。

实现可迭代接口的数据结构，一般都自身实现或继承了以`Symbol.iterator`属性的，就属于可迭代对象。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。

一个包含`next()`方法的对象，才可以称为一个迭代对象。`next()`对象的会有返回一个对象，对象中包含两个值，如下所示：

- `value`：迭代器返回的任何`JavaScript`值。`done`为`true`时可省略。
- `done`：一个布尔值，为`false`时表示迭代未停止，为`true`时立即停止迭代器，且可以省略`value`的值。

Iterator 的作用有三个：

1. 为各种数据结构，提供一个统一的、简便的访问接口；
2. 使得数据结构的成员能够按某种次序排列；
3. ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。
   :::

### 12. for...of..循环

::: tip
`for...of`循环，作为遍历所有数据结构的统一的方法。

一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有 iterator 接口，就可以用`for...of`循环遍历它的成员。也就是说，`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。

`for...of`循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如`arguments`对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。
:::

### 13. Generator

::: tip
Generator 是 ES2015 中提供的一种异步编程解决方案，定义 Generator 函数在`function`关键字和函数名中间使用`*`星号，函数内部使用`yield`关键字定义不同的状态。

async 的底层就是 Generator 函数
:::

### 14. Proxy 和 Reffect

::: tip
Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

Proxy 对象用于创建一个代理对象，从而实现基本操作的拦截和自定义，基本操作包含 13 种，如下表所示：

| 拦截 ⽅法                                   | 触发⽅式                                                                           |
| ------------------------------------------- | ---------------------------------------------------------------------------------- |
| `get(target, propKey, receiver)`            | 读取某个属性                                                                       |
| `set(target, propKey, value, receiver)`     | 写⼊某个属性                                                                       |
| `has(target, propKey)`                      | `in`操作符                                                                         |
| `deleteProperty(target, propKey)`           | `delete`操作符                                                                     |
| `getPrototypeOf(target)`                    | `Object.getPropertypeOf()`                                                         |
| `setPrototypeOf(target, proto)`             | `Object.setPrototypeOf()`                                                          |
| `isExtensible(target)`                      | `Object.isExtensible()`                                                            |
| `preventExtensions(target)`                 | `Object.preventExtensions()`                                                       |
| `getOwnPropertyDescriptor(target, propKey)` | `Object.getOwnPropertyDescriptor()`                                                |
| `defineProperty(target, propKey, propDesc)` | `Object.defineProperty()`                                                          |
| `ownKeys(target)`                           | `Object.keys()` 、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()` |
| `apply(target, thisArg, args)`              | 调⽤⼀个函数                                                                       |
| `construct(target, args)`                   | ⽤ new 调⽤⼀个函数                                                                |

Vue3 就是基于`Proxy`进行编写的

**Reflect**是 ECMAScript2015 提供的一个对象，它提供了一些拦截 JavaScript 操作的静态方法，这些方法与 Proxy 中的`handlers`中的方法一致。

Reflect 并不是一个构造函数，也就是说它不能够被实例化。

`Proxy`对象中的每一个拦截操作（例如：`get`、`delete`等）,内部都对应的调用了`Reflect`的方法。它提供的静态方法与 Proxy 中的`handlers`中的方法名称都一致
:::

### 15. Set、Map、WeakSet、WeakMap

::: tip
`Set`、`Map`、`WeakSet`、`WeakMap`是 ES2015 中新增的几个对象：

**set**类似于数组，但是成员的值都是唯一的，没有重复的值。

`Set`本身是一个构造函数，用来生成 Set 数据结构。

`Set`和`WeakSet`与数组类似，准确的它他们是集合，这两者的区别就是`Set`可以存储任何数据类型，而`WeakSet`只能存储对象的引用，而且是弱引用；

`Set`对象在实际开发中最常见的就是实现数据去重，示例代码如下：

```js
const arr = [1, 2, 2, 3, 4, 3, 5];
const set = new Set(arr);
// set对象可以使用 ... 展开 所有项
console.log([...set]); // [ 1, 2, 3, 4, 5 ]
```

**map**类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

`Map`和`WeakMap`与对象类似，存储方式是键值对形式的，这两者的区别`Map`的键值对都是可以是任意的而`WeakMap`键必须是对象的引用而值可以是任意类型的。
:::

## 6.2 ES2016

### 1. 指数运算符

::: tip
ES2016 中新增指数`**`，也叫幂运算符，与 Math.pow()有着一样的功能，示例代码如下：

```js
console.log(2 ** 10 === Math.pow(2, 10)); // true
```

:::

### 2. Array.prototype.includes()方法

::: tip
在 ES2016 中在数组原型上增加了`includes()`方法，该方法用于判断一个数组中是否包含指定的值，返回一个布尔值，示例代码如下：

```js
const arr = [1, 2, 3, 4, 5, NaN];
console.log(arr.indexOf(NaN)); // -1
console.log(arr.includes(NaN)); // true
```

值得注意的是使用`includes()`时`NaN`与`NaN`、`+0`与`-0`是相等的。
:::

## 6.3 ES2017

### 1. 对象新增方法

::: tip

- `Object.values()`：返回一个给定对象自身的所有可枚举属性值的数组；
- `Object.entries()`：返回一个给定对象自身可枚举属性的键值对数组；
- `Object.getOwnPropertyDescriptors()`：返回给定对象所有自有属性的属性描述符。
  :::

### 2. 字符串新增方法

::: tip

- `padStart()`：在字符串开头填充空格；
- `padEnd()`：在字符串结尾填充空格；
  :::

## 6.4 ES2018

### 1. 异步迭代

::: tip
在 ES2018 中新增了`for await...of`语句，该用于可以遍历异步可迭代对象
:::

### 2.**对象扩展运算符**

::: tip
对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。

```js
let bar = { a: 1, b: 2 };
let baz = { ...bar }; // { a: 1, b: 2 }
```

上述方法实际上等价于:

```js
let bar = { a: 1, b: 2 };
let baz = Object.assign({}, bar); // { a: 1, b: 2 }
```

`Object.assign`方法用于对象的合并，将源对象`（source）`的所有可枚举属性，复制到目标对象`（target）`。`Object.assign`方法的第一个参数是目标对象，后面的参数都是源对象。(**如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性**)
:::

### 3. Promise.prototype.finally

::: tip
`finally()`方法会返回一个`Promise`对象，当 promise 的状态变更，不管是变成`rejected`或者`fulfilled`，最终都会执行`finally()`的回调。
:::

## 6.5 ES2019

### 1. `try...catch`：语句中的`catch`允许不使用参数

### 2. trimStart、trimLeft、trimEnd、trimRight

::: tip

- `String.prototype.trimStart`：用于去除字符串左边的空格；
- `String.prototype.trimLeft`：它是`trimStart`的别名
- `String.prototype.trimEnd`：用于去除字符串右边的空格；
- `String.prototype.trimRight`：它是`trimEnd`的别名
  :::

### 3. Object.fromEntries

::: tip
`Object.fromEntries()`方法把键值对列表转换为一个对象，是`Object.entries()`方法的反操作
:::

## 6.6 ES2020

### 1. 动态导入

::: tip
动态导入，也就是我们需要该模块的时候才会进行加载，这可以减少开销和页面加载时间，示例代码如下：

```js
import("/modules/my-module.js").then((module) => {
  // Do something with the module.
});
```

动态导入使用`import()`方法，它返回一个 Promise。

在 ES2020 中，还为`import`增加一个`meta`对象，该对象给 JavaScript 模块暴露了特定上下文的元数据属性的对象。
:::

### 2. BigInt 数据类型

::: tip
BigInt 的出现时解决 JavaScript 中允许的最大数字是`2**53-1`的问题，`BigInt` 可以表示任意大的整数。
:::

### 3. 空值合并运算符 ??

::: tip
该运算符与逻辑或运算符类似。其计算规则为，只要左运算元为`null`或者`undefined`，则返回右运算元，否则返回左运算元。而逻辑或运算符只有左运算元转换为`boolean`类型后为`false`，就返回右运算元。
:::

### 4. 可选链操作符 ?.

::: tip
`?.` 操作符的功能类似于 `.` 链式操作符，不同之处在于，在引用为空 ([nullish](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FNullish) ) ([`null`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fnull) 或者 [`undefined`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2Fundefined)) 的情况下不会引起错误，该表达式短路返回值是 `undefined`。

当我们访问某个属性时，只要有一处不存在，就会返回`undefind`，不会报错。

```js
var A = {};

// console.log(A.a.b) // 报错

console.log(A.a?.b); // undefined
```

可选链操作符也可用于对象下方法的调用，示例代码如下：

```js
var obj = {};

// 如果存在 obj.fun() 这个方法，下面则会直接调用，如果不存在则会返回undefined
obj.fun?.A();
```

:::

## 6.7 ES2021

### 1. String.prototype.replaceAll

::: tip
`replaceAll()`方法返回一个新字符串，新字符串的内容是经过替换的，实例代码如下：

```js
const str = "刘逍";
const newStr = str.replaceAll("逍", "小");
console.log(newStr); // 刘小
```

:::

### 2. 数值分隔符 \_

::: tip
严格意义上讲数值分隔符(`_`)并不属于一个运算符，其作用就是使数字更加利于阅读，例如下面的代码

```js
console.log(1_0000_0000); // 100000000
```

:::

### 3. Promise.any()

::: tip
ES2021 中新增的`Promise.any()`方法，它接受的参数和与`promise.all()`是一致的，唯一不同的是，`Promise.any()`方法接受的可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和 AggregateError 类型的实例。
:::

### 4. 逻辑赋值操作符 &&= 、||= 、？？=

::: tip

```js
const [f1, f2, f3] = [true, false];
f1 &&= "逍"; // 等同于 str = str && '逍'
f2 ||= "逍"; // 等同于 str = str || '逍'
f3 ??= "逍"; // 等同于 str = str ?? '逍'
```

:::

## 6.8 ES2022

### 1. class 的扩展

::: tip
在 ES2022 中允许我们并不在`constructor`中定义类的成员，示例代码如下：

```js
class C {
  myName = "刘逍";
}
/* 两者是一致的 */
class C {
  constructor() {
    myName = "刘逍";
  }
}
```

ES2022 中允许我们使用`#`开头命名的变量作为类的私有成员
:::

### 2. await 在顶层使用

::: tip
在 ES2022 中新增了允许在顶层使用`await`，在顶层可以不适用`async`函数进行包裹，示例代码如下：

```js
import { AsyncFun } from "module";
await AsyncFun();
console.log(123);
```

:::

### 3. Object.hasOwn()

::: tip
`Object.hasOwn()`方法用于判断某个对象上是否具有某个属性，示例代码如下：

```javascript
const person = {
  name: "刘逍",
  age: 18,
};
console.log(Object.hasOwn(person, "name")); // true
console.log(Object.hasOwn(person, "sex")); // false
```

:::

### 4. Array.prototype.at()

::: tip
ES2022 中新增的`at()`方法，它的作用是获取数组中的某个成员，它的参数是数组的索引，与直接使用索引的方式不同，它允许我们传递负值，等同于从后面倒数，示例代码如下：

```js
const arr = [1, 2, 3, 4, 5, 6];
console.log(arr.at(-1)); // 6
// 等同于 arr[arr.length - 1]
```

:::

# 七、 DOM

## 7.1 说一下 DOM 事件流

::: tip
⼜称为事件传播，是⻚⾯中接收事件的顺序。DOM2 级事件规定的事件流包括了 3 个阶段：

- 事件捕获阶段（capture phase）
- 处于⽬标阶段（target phase）
- 事件冒泡阶段（bubbling phase）

![Snipaste_2022-08-22_18-26-46.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152eeaa11c2c4ca9a93de8a484295bcd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

如上图所示，事件流的触发顺序是：

1. 事件捕获阶段，为截获事件提供了机会
2. 实际的⽬标元素接收到事件
3. 事件冒泡阶段，可在这个阶段对事件做出响应
   :::

## 7.2 什么是事件冒泡（Event Bubbling）

::: tip
事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。

```html
<html>
  <head>
    <title>Document</title>
  </head>

  <body>
    <button>按钮</button>
  </body>
</html>
```

如果点击了上面页面代码中的 `<button>` 按钮，那么该 `click` 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：

1. button 元素
2. body 元素
3. html 元素
4. document 对象
   :::

## 7.3 什么是事件捕获（Event Capturing）

::: tip
事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。

事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。

如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 `click` 事件，然后再沿着 DOM 树依次向下，直到 `<button>`。具体顺序如下：

1. document 对象
2. html 元素
3. body 元素
4. button 元素
   :::

## 7.4 什么是事件委托

::: tip
事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。

适用场景：在绑定大量事件的时候，可以选择事件委托

**优点**

- 事件委托可以减少事件注册数量，节省内存占⽤!
- 当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素 (vue 解析模板时, 会对新创建的元素, 额外进行绑定的)
  :::

## 7.5 什么是 DOM

::: tip
DOM 就是文档对象模型 ，是用来呈现以及与任意 `HTML` 和或`XML` 文档交互的 API

它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容
:::

## 7.6 DOM 的常用操作

### (1)创建节点

::: tip
**createElement**

创建新元素，接受一个参数，即要创建元素的标签名

```js
const divEl = document.createElement("div");
```

**createTextNode**

创建一个文本节点

```js
const textEl = document.createTextNode("content");
```

**createDocumentFragment**

用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到`DOM`中

```js
const fragment = document.createDocumentFragment();
```

当请求把一个`DocumentFragment` 节点插入文档树时，插入的不是 `DocumentFragment`自身，而是它的所有子孙节点

**createAttribute**

创建属性节点，可以是自定义属性

```js
const dataAttribute = document.createAttribute("custom");
consle.log(dataAttribute);
```

:::

### (2)获取节点

::: tip
**querySelector**

传入任何有效的`css` 选择器，即可选中单个 `DOM`元素（首个）：

```js
document.querySelector(".element");
document.querySelector("#element");
document.querySelector("div");
document.querySelector('[name="username"]');
document.querySelector("div + p > span");
```

如果页面上没有指定的元素时，返回 `null`

**querySelectorAll**

返回一个包含节点子树内所有与之相匹配的`Element`节点列表，如果没有相匹配的，则返回一个空节点列表

```js
const notLive = document.querySelectorAll("p");
```

需要注意的是，该方法返回的是一个 `NodeList`的静态实例，它是一个静态的“快照”，而非“实时”的查询

关于获取`DOM`元素的方法还有如下，就不一一述说

```javascript
document.getElementById("id属性值");
返回拥有指定id的对象的引用;
document.getElementsByClassName("class属性值");
返回拥有指定class的对象集合;
document.getElementsByTagName("标签名");
返回拥有指定标签名的对象集合;
document.getElementsByName("name属性值");
返回拥有指定名称的对象结合;
document / element.querySelector("CSS选择器");
仅返回第一个匹配的元素;
document / element.querySelectorAll("CSS选择器");
返回所有匹配的元素;
document.documentElement;
获取页面中的HTML标签;
document.body;
获取页面中的BODY标签;
document.all[""];
获取页面中的所有元素节点的对象集合型;
```

:::

### (3)更新节点

::: tip
**innerHTML**

不但可以修改一个`DOM`节点的文本内容，还可以直接通过`HTML`片段修改`DOM`节点内部的子树

```css
// 获取<p id="p">...</p >
var p = document.getElementById('p');
// 设置文本为abc:
p.innerHTML = 'ABC'; // <p id="p">ABC</p >
// 设置HTML:
p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
// <p>...</p >的内部结构已修改
```

**innerText、textContent**

自动对字符串进行`HTML`编码，保证无法设置任何`HTML`标签

```js
// 获取<p id="p-id">...</p >
var p = document.getElementById("p-id");
// 设置文本:
p.innerText = '<script>alert("Hi")</script>';
// HTML被自动编码，无法设置一个<script>节点:
// <p id="p-id">&lt;script&gt;alert("Hi")&lt;/script&gt;</p >
```

两者的区别在于读取属性时，`innerText`不返回隐藏元素的文本，而`textContent`返回所有文本

**style**

`DOM`节点的`style`属性对应所有的`CSS`，可以直接获取或设置。遇到`-`需要转化为驼峰命名

```js
// 获取<p id="p-id">...</p >
const p = document.getElementById("p-id");
// 设置CSS:
p.style.color = "#ff0000";
p.style.fontSize = "20px"; // 驼峰命名
p.style.paddingTop = "2em";
```

:::

### (4)添加节点

::: tip
**innerHTML**

如果这个 DOM 节点是空的，例如，`<div></div>`，那么，直接使用`innerHTML = '<span>child</span>'`就可以修改`DOM`节点的内容，相当于添加了新的`DOM`节点

如果这个 DOM 节点不是空的，那就不能这么做，因为`innerHTML`会直接替换掉原来的所有子节点

**appendChild**

把一个子节点添加到父节点的最后一个子节点

如果是获取`DOM`元素后再进行添加操作，这个`js`节点是已经存在当前文档树中，因此这个节点首先会从原先的位置删除，再插入到新的位置

如果动态添加新的节点，则先创建一个新的节点，然后插入到指定的位置

**insertBefore**

把子节点插入到指定的位置，使用方法如下：

```scss
parentElement.insertBefore(newElement, referenceElement)

```

子节点会插入到`referenceElement`之前

**setAttribute**

添加一个属性节点，如果元素中已有该属性改变属性值

```javascript
const div = document.getElementById("id");
div.setAttribute("class", "white"); //第一个参数属性名，第二个参数属性值。
```

:::

### (5)删除节点

::: tip
**removeChild**

删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的`removeChild`把自己删掉

```js
// 拿到待删除节点:
const self = document.getElementById("to-be-removed");
// 拿到父节点:
const parent = self.parentElement;
// 删除:
const removed = parent.removeChild(self);
removed === self; // true
```

删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置
:::

## 7.7 什么是 DOM 树

::: tip
以 HTMLDocument 为根节点，其余节点为子节点，组织成一个树的数据结构的表示就是 DOM 树。

DOM 树直接体现了标签与标签之间的关系
:::

## 7.8 什么是 DOM 对象，什么是 document 对象

::: tip
DOM 对象是浏览器根据 html 标签生成的 Js 对象

docement 对象是 DOM 里提供的一个对象，它提供的属性和方法都是用来访问和操作网页内容的
:::

## 7.9 L0 和 L2 注册事件的区别

::: tip
![Snipaste_2022-08-22_18-46-17.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4328d62ad5e54a66b4aed311f2c2d954~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)
:::

## 7.10 怎么解绑事件

::: tip
![Snipaste_2022-08-22_18-47-08.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c245425aef478b907f84c84f331c70~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)
:::

## 7.11 addEventListener 的第三个参数有什么用

::: tip
addEventListener 有三个参数：

```vbnet
 element.addEventListener(event, function, useCapture)

```

| 参数       | 描述                                                                                                                                                                                                                                                                           |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| event      | 必须。字符串，指定事件名。 **注意:** 不要使用 "on" 前缀。 例如，使用 "click" ,而不是使用 "onclick"。 **提示：** 所有 HTML DOM 事件，可以查看我们完整的 [HTML DOM Event 对象参考手册](https://link.juejin.cn?target=http%3A%2F%2Fwww.runoob.com%2Fjsref%2Fdom-obj-event.html)。 |
| function   | 必须。指定要事件触发时执行的函数。 当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， "click" 事件属于 MouseEvent(鼠标事件) 对象。                                                                                                                    |
| useCapture | 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。 可能值:true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）                                                                      |

:::

## 7.12 常用 DOM 事件

::: tip

- 鼠标事件
  - 鼠标单击 click
  - 鼠标双击 dblclick
  - 鼠标移入/移出
    - mouseover/mouseout : 支持冒泡
    - mouseenter/mouseleave： 不支持冒泡
  - 鼠标移动 mousemove
  - 鼠标按下 mousedown
  - 鼠标松开 mouseup
- 键盘事件
  - input : 键盘输入
  - keydwon : 键盘按下
  - focus: 成为焦点
  - blur: 失去焦点
- 页面事件
  - scroll ： 页面滚动
  - resize：页面大小变化
    :::

## 7.13 怎么阻止事件冒泡、阻止默认事件？

::: tip
**阻止事件冒泡**

e.stopPropagation\*\*()

**阻止默认事件,3 种方式**

```js
e.preventDefault(); //谷歌及IE8以上
window.event.returnValue = false; //IE8及以下
return false; //无兼容问题（但不能用于节点直接onclick绑定函数）
```

:::

## 7.14 DOM 的类型有哪几种？

::: tip
12 种

```scss
元素节点            　　Node.ELEMENT_NODE(1)
属性节点            　　Node.ATTRIBUTE_NODE(2)
文本节点            　　Node.TEXT_NODE(3)
CDATA节点             Node.CDATA_SECTION_NODE(4)
实体引用名称节点    　　 Node.ENTRY_REFERENCE_NODE(5)
实体名称节点        　　Node.ENTITY_NODE(6)
处理指令节点        　　Node.PROCESSING_INSTRUCTION_NODE(7)
注释节点            　 Node.COMMENT_NODE(8)
文档节点            　 Node.DOCUMENT_NODE(9)
文档类型节点        　　Node.DOCUMENT_TYPE_NODE(10)
文档片段节点        　　Node.DOCUMENT_FRAGMENT_NODE(11)
DTD声明节点            Node.NOTATION_NODE(12)
```

:::

## 7.15 DOM 种获取坐标的属性有哪些，它们有什么不同？

::: tip
| 属性 | 说明 | 兼容性 |
| ------- | ------------------------------------------------------------ | ----------------- |
| offsetX | 以当前的目标元素左上角为原点，定位 x 轴坐标 | 除 Mozilla 外都兼容 |
| offsetY | 以当前的目标元素左上角为原点，定位 y 轴坐标 | 除 Mozilla 外都兼容 |
| clientX | 以浏览器可视窗口左上角为原点，定位 x 轴坐标 | 都兼容 |
| clientY | 以浏览器可视窗口左上角为原点，定位 y 轴坐标 | 都兼容 |
| pageX | 以 doument 对象左上角为原点，定位 x 轴坐标 | 除 IE 外都兼容 |
| pageY | 以 doument 对象左上角为原点，定位 y 轴坐标 | 除 IE 外都兼容 |
| screenX | 以计算机屏幕左上顶角为原点，定位 x 轴坐标(多屏幕会影响) | 全兼容 |
| screenY | 以计算机屏幕左上顶角为原点，定位 y 轴坐标 | 全兼容 |
| layerX | 最近的绝对定位的父元素（如果没有，则为 document 对象）左上顶角为元素，定位 x 轴坐标 | Mozilla 和 Safari |
| layerY | 最近的绝对定位的父元素（如果没有，则为 document 对象）左上顶角为元素，定位 y 轴坐标 | Mozilla 和 Safari |
:::

## 7.16 DOM 种元素视图尺寸的属性有哪些？

::: tip
| 属性 | 说明 |
| ------------ | ------------------------------------------------------------ |
| offsetLeft | 获取当前元素到定位父节点的 left 方向的距离 |
| offsetTop | 获取当前元素到定位父节点的 top 方向的距离 |
| offsetWidth | 获取当前元素 width + 左右 padding + 左右 border-width |
| offsetHeight | 获取当前元素 height + 上下 padding + 上下 border-width |
| clientWidth | 获取当前元素 width + 左右 padding |
| clientHeight | 获取当前元素 height + 上下 padding |
| scrollWidth | 当前元素内容真实的宽度，内容不超出盒子宽度时为盒子的 clientWidth |
| scrollHeight | 当前元素内容真实的高度，内容不超出盒子高度时为盒子的 clientHeight |
:::

## 7.17 如何判断元素是否在可视区域

::: tip

### getBoundingClientRect

```
Element.getBoundingClientRect()` 方法返回元素的大小及其相对于视口的位置。返回的是一个对象，对象里有这8个属性：`left，right，top，bottom，width，height，x，y
```

:::

## 7.18 IntersectionObserver

::: tip
`IntersectionObserver`**接口** 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗([viewport](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FViewport))交叉状态的方法。祖先元素与视窗([viewport](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FViewport))被称为**根(root)**

通俗点说就是：`IntersectionObserver`是用来监听**某个元素与视口**的`交叉状态`的。
:::

## 7.19 如何遍历输出页面中的所有元素

::: tip

### createNodeIterator

使用`createNodeIterator`对页面中所有元素进行遍历输出呢？

```js
const body = document.getElementsByTagName("body")[0];
const it = document.createNodeIterator(body);
let root = it.nextNode();
while (root) {
  console.log(root);
  root = it.nextNode();
}
```

:::

## 7.20 什么是 BOM 对象

::: tip
![Snipaste_2022-08-22_18-53-44.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d02d3f7e82ce497eb64f8bb03a02a9cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

### (1) location 对象的常用方法

![Snipaste_2022-08-22_18-54-33.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afee995fe98e42b983727698a8d4e1ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

### (2) navigator 对象 (获取浏览器平台和版本数据)

![Snipaste_2022-08-22_18-55-25.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0121daea446e484b87746930d3545777~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

### (3) histroy 对象 （管理浏览器历史记录）

![Snipaste_2022-08-22_18-57-03.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886d847bf7984663b41d1acb8329c509~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)
:::

# 八、其他类型问题补充

## 8.1 简单说说你对观察者模式的理解

::: tip
观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新

观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/455aea9a384646bebf4521ebbbd07d34~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸

报社和订报纸的客户就形成了一对多的依赖关系
:::

## 8.2 简单说说你对发布订阅模式的理解

::: tip
发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在

同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在
:::

## 8.3 观察者模式与发布订阅的区别

::: tip

- 在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。
- 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。
- 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）
  :::

## 8.4 说说你对正则表达式的理解

::: tip
正则表达式是一种用来匹配字符串的强有力的武器

它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的

在 `JavaScript`中，正则表达式也是对象，构建正则表达式有两种方式：

1. 字面量创建，其由包含在斜杠之间的模式组成

```js
const re = /\d+/g;
```

1. 调用`RegExp`对象的构造函数

```js
const re = new RegExp("d+", "g");

const rul = "d+";
const re1 = new RegExp(rul, "g");
```

使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符``需要使用`\`进行转义
:::

## 8.5 如何判断当前的 Js 代码是否在浏览器环境中运行

::: tip
如果 Javascript 在浏览器环境中运行，则会有一个全局对象：`window`。因此，可以通过以下方式判断环境：

```javascript
 typeof window.self ！== "undefined";
 // 在web worker或者sevice worker下是无法获取到windows全局变量， 所以需要通过self变量判断
```

:::
